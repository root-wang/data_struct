## 栈和递归

### 递归定义
> 一个对象的一部分包含他自己 或者自己给自己定义
> 若一个过程**直接或者间接的**调用自己

	1. 递归定义的数学函数
		1. 阶乘函数 
		2. 阶斐波那契数列
	2. 具有递归特性的数据结构
		1. 二叉树
		2. 广义表
	3. 可递归求解的问题
		1. 迷宫问题
		2. 汉诺塔问题

### 分治法
	对于一个较为复杂的问题能够分成几个相对简单的且解法相同或类似的
	子问题来求解
	
	必备的三个条件
		1. 能将一个问题转换为一个新问题 而新问题与原来问题的解法
               相同,不同的只是处理的对象 而且这些处理对象是变化
               有规律的.
		2. 可以通过上述转换而使得问题简化
		3. 必须有一个明确的递归出口 或称为递归的边界

### 求解问题算法一般形式
```c++
void p(parameter){
    if(递归结束条件) 直接求解//基本项
    else p(parameter--)//归纳项
}
```
### 函数调用过程
	1. 调用前,系统完成
		1) 将实参,返回地址等传递给被调用函数
		2) 为被调用函数的局部变量分配存储区
		3) 将控制转移到被调用的函数入口
	2. 调用后,系统完成
		1) 保存被调用函数的计算结果
		2) 释放被调用函数的数据区
		3) 依照被调用函数保存的返回地址将控制转移到调用函数
> 遵循后调用的先返回

	递归工作栈

### 递归优缺点
	优点: 结构清晰 程序易读
	缺点: 每次调用都要生成工作记录 时间开销大

	递归程序 --> 非递归
	1. 尾递归 单向递归-->循环结构(阶乘,斐波那契数列)
	2. 自用栈模拟递归
	但是结构不清晰 可读性差 有时需要经过一系列优化